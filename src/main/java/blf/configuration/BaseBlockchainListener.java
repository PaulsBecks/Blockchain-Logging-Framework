package blf.configuration;

import blf.core.Program;
import blf.core.exceptions.ExceptionHandler;
import blf.core.instructions.SetOutputFolderInstruction;
import blf.core.state.ProgramState;
import blf.grammar.BcqlBaseListener;
import blf.grammar.BcqlParser;
import blf.parsing.InterpreterUtils;
import blf.parsing.VariableExistenceListener;
import blf.util.ListenerHelper;
import blf.util.TypeUtils;

import java.util.*;
import java.util.function.BinaryOperator;
import java.util.logging.Logger;

/**
 * The abstract BaseBlockchainListener class implements blockchain unspecific callback functions, which are triggered
 * when a parse tree walker enters or exits corresponding parse tree nodes. These callback functions handle how the
 * program should process the input of the manifest file.
 * It extends the BcqlBaseListener class, which is an empty listener template generated by ANTLR4 for the grammar.
 */

public abstract class BaseBlockchainListener extends BcqlBaseListener {
    private static final Logger LOGGER = Logger.getLogger(BaseBlockchainListener.class.getName());

    protected Program program;
    protected ProgramState state;
    protected BuildException error;
    protected final VariableExistenceListener variableAnalyzer;
    protected final SpecificationComposer composer = new SpecificationComposer();
    protected final Deque<Object> genericFilterPredicates = new ArrayDeque<>();

    public ProgramState getState() {
        return this.state;
    }

    public Program getProgram() {
        return this.program;
    }

    public BuildException getError() {
        return this.error;
    }

    public boolean containsError() {
        return this.error != null;
    }

    protected BaseBlockchainListener(VariableExistenceListener analyzer) {
        this.variableAnalyzer = analyzer;
    }

    @Override
    public void enterBlockchain(BcqlParser.BlockchainContext ctx) {
        LOGGER.info("Prepare program build");
        this.error = null;
        this.composer.prepareProgramBuild();
    }

    @Override
    public void enterOutputFolder(BcqlParser.OutputFolderContext ctx) {
        final String literalText = ListenerHelper.getOutputFolderLiteral(ctx);
        if (literalText == null) {
            return;
        }

        this.state.outputFolderPath = TypeUtils.parseStringLiteral(literalText);

        this.composer.addInstruction(new SetOutputFolderInstruction());
    }

    @Override
    public void enterEmissionMode(BcqlParser.EmissionModeContext ctx) {
        if (ctx == null) {
            ExceptionHandler.getInstance().handleException("EmissionModeContext is null.", new NullPointerException());

            return;
        }

        final BcqlParser.LiteralContext emissionModeLiteralCtx = ctx.literal();

        if (emissionModeLiteralCtx.STRING_LITERAL() == null) {
            ExceptionHandler.getInstance().handleException("EMISSION MODE parameter should be a String.", new NullPointerException());

            return;
        }

        final String emissionModeStringLiteral = emissionModeLiteralCtx.STRING_LITERAL().getText();
        final String emissionMode = TypeUtils.parseStringLiteral(emissionModeStringLiteral);
        final Map<String, EmissionSettings.EmissionMode> emissionModeMap = EmissionSettings.getEmissionModeMap();

        if (!emissionModeMap.containsKey(emissionMode)) {
            ExceptionHandler.getInstance()
                .handleException(
                    "EMISSION MODE parameter should be either \"default batching\", \"safe batching\" or \"streaming\".",
                    new Exception()
                );

            return;
        }

        this.state.setEmissionMode(emissionModeMap.get(emissionMode));
    }

    @Override
    public void enterAbortOnException(BcqlParser.AbortOnExceptionContext ctx) {
        if (ctx == null) {
            ExceptionHandler.getInstance().handleException("AbortOnExceptionContext is null.", new NullPointerException());

            return;
        }

        if (ctx.BOOLEAN_LITERAL() == null) {
            ExceptionHandler.getInstance().handleException("EMISSION MODE parameter should be a Boolean.", new NullPointerException());

            return;
        }

        boolean abortionFlag = Boolean.parseBoolean(ctx.BOOLEAN_LITERAL().getText());

        ExceptionHandler.getInstance().setAbortOnException(abortionFlag);
    }

    @Override
    public void exitDocument(BcqlParser.DocumentContext ctx) {
        LOGGER.info("Build program");
        this.program = this.composer.buildProgram();
        this.genericFilterPredicates.clear();
    }

    @Override
    public void exitEmitStatementLog(BcqlParser.EmitStatementLogContext ctx) {
        this.handleEmitStatementLog(ctx);
    }

    private void handleEmitStatementLog(BcqlParser.EmitStatementLogContext ctx) {
        final List<ValueAccessorSpecification> accessors = new LinkedList<>();
        for (BcqlParser.ValueExpressionContext valEx : ctx.valueExpression()) {
            accessors.add(this.getValueAccessor(valEx));
        }
        final LogLineExportSpecification spec = LogLineExportSpecification.ofValues(accessors);

        this.composer.addInstruction(spec);
    }

    @Override
    public void exitEmitStatementCsv(BcqlParser.EmitStatementCsvContext ctx) {
        this.handleEmitStatementCsv(ctx);
    }

    private void handleEmitStatementCsv(BcqlParser.EmitStatementCsvContext ctx) {
        LinkedList<CsvColumnSpecification> columns = new LinkedList<>();

        for (BcqlParser.NamedEmitVariableContext varCtx : ctx.namedEmitVariable()) {
            final String name = varCtx.valueExpression().variableName() == null
                ? varCtx.variableName().getText()
                : varCtx.valueExpression().variableName().getText();
            final ValueAccessorSpecification accessor = this.getValueAccessor(varCtx.valueExpression());
            columns.add(CsvColumnSpecification.of(name, accessor));
        }
        this.composer.addInstruction(CsvExportSpecification.of(this.getValueAccessor(ctx.tableName), columns));
    }

    @Override
    public void exitEmitStatementHttpRequest(BcqlParser.EmitStatementHttpRequestContext ctx) {
        LinkedList<CsvColumnSpecification> variables = new LinkedList<>();

        for (BcqlParser.NamedEmitVariableContext varCtx : ctx.namedEmitVariable()) {
            final String name = varCtx.valueExpression().variableName() == null
                ? varCtx.variableName().getText()
                : varCtx.valueExpression().variableName().getText();
            final ValueAccessorSpecification accessor = this.getValueAccessor(varCtx.valueExpression());
            variables.add(CsvColumnSpecification.of(name, accessor));
        }
        this.composer.addInstruction(HttpExportSpecification.of(this.getValueAccessor(ctx.uri), variables));
    }

    @Override
    public void exitMethodStatement(BcqlParser.MethodStatementContext ctx) {
        this.addMethodCall(ctx.methodInvocation(), null);
    }

    @Override
    public void exitVariableAssignmentStatement(BcqlParser.VariableAssignmentStatementContext ctx) {
        this.addVariableAssignment(ctx.variableName(), ctx.statementExpression());
    }

    @Override
    public void exitVariableDeclarationStatement(BcqlParser.VariableDeclarationStatementContext ctx) {
        this.addVariableAssignment(ctx.variableName(), ctx.statementExpression());
    }

    private void addVariableAssignment(BcqlParser.VariableNameContext varCtx, BcqlParser.StatementExpressionContext stmtCtx) {
        final String varName = varCtx.getText();
        final ValueMutatorSpecification mutator = ValueMutatorSpecification.ofVariableName(varName);

        if (stmtCtx.valueExpression() != null) {
            this.addValueAssignment(mutator, stmtCtx.valueExpression());

            return;
        }

        if (stmtCtx.methodInvocation() != null) {
            this.addMethodCall(stmtCtx.methodInvocation(), mutator);

            return;
        }

        ExceptionHandler.getInstance()
            .handleException("Adding variable assignment failed: This type of value definition is not supported.", new Exception());
    }

    private void addValueAssignment(ValueMutatorSpecification mutator, BcqlParser.ValueExpressionContext ctx) {
        final ValueAccessorSpecification accessor = this.getValueAccessor(ctx);
        final ValueAssignmentSpecification assignment = ValueAssignmentSpecification.of(mutator, accessor);

        this.composer.addInstruction(assignment);
    }

    private void addMethodCall(BcqlParser.MethodInvocationContext ctx, ValueMutatorSpecification mutator) {
        final List<String> parameterTypes = new ArrayList<>();
        final List<ValueAccessorSpecification> accessors = new ArrayList<>();

        for (BcqlParser.ValueExpressionContext valCtx : ctx.valueExpression()) {
            parameterTypes.add(InterpreterUtils.determineType(valCtx, this.variableAnalyzer));
            accessors.add(this.getValueAccessor(valCtx));
        }

        final MethodSpecification method = MethodSpecification.of(ctx.methodName.getText(), parameterTypes);

        if (method == null) {
            ExceptionHandler.getInstance()
                .handleException("Adding method call failed: Method specification is null.", new NullPointerException());

            return;
        }

        final MethodCallSpecification call = MethodCallSpecification.of(method, mutator, accessors);

        this.composer.addInstruction(call);
    }

    @Override
    public void exitEmitStatementXesTrace(BcqlParser.EmitStatementXesTraceContext ctx) {
        this.handleEmitStatementXesTrace(ctx);
    }

    private void handleEmitStatementXesTrace(BcqlParser.EmitStatementXesTraceContext ctx) {
        final ValueAccessorSpecification pid = this.getXesId(ctx.pid);
        final ValueAccessorSpecification piid = this.getXesId(ctx.piid);
        final List<XesParameterSpecification> parameters = this.getXesParameters(ctx.xesEmitVariable());

        this.composer.addInstruction(XesExportSpecification.ofTraceExport(pid, piid, parameters));
    }

    @Override
    public void exitEmitStatementXesEvent(BcqlParser.EmitStatementXesEventContext ctx) {
        this.handleEmitStatementXesEvent(ctx);
    }

    private void handleEmitStatementXesEvent(BcqlParser.EmitStatementXesEventContext ctx) {
        final ValueAccessorSpecification pid = this.getXesId(ctx.pid);
        final ValueAccessorSpecification piid = this.getXesId(ctx.piid);
        final ValueAccessorSpecification eid = this.getXesId(ctx.eid);
        final List<XesParameterSpecification> parameters = this.getXesParameters(ctx.xesEmitVariable());

        this.composer.addInstruction(XesExportSpecification.ofEventExport(pid, piid, eid, parameters));
    }

    private ValueAccessorSpecification getXesId(BcqlParser.ValueExpressionContext ctx) {
        return ctx == null ? null : this.getValueAccessor(ctx);
    }

    private List<XesParameterSpecification> getXesParameters(List<BcqlParser.XesEmitVariableContext> variables) {
        final LinkedList<XesParameterSpecification> parameters = new LinkedList<>();

        for (BcqlParser.XesEmitVariableContext varCtx : variables) {
            final String name = varCtx.variableName() == null
                ? varCtx.valueExpression().variableName().getText()
                : varCtx.variableName().getText();
            final ValueAccessorSpecification accessor = this.getValueAccessor(varCtx.valueExpression());

            LOGGER.info(varCtx.getText());

            XesParameterSpecification parameter;
            switch (varCtx.xesTypes().getText()) {
                case "xs:string":
                    parameter = XesParameterSpecification.ofStringParameter(name, accessor);
                    break;
                case "xs:date":
                    parameter = XesParameterSpecification.ofDateParameter(name, accessor);
                    break;
                case "xs:int":
                    parameter = XesParameterSpecification.ofIntegerParameter(name, accessor);
                    break;
                case "xs:float":
                    parameter = XesParameterSpecification.ofFloatParameter(name, accessor);
                    break;
                case "xs:boolean":
                    parameter = XesParameterSpecification.ofBooleanParameter(name, accessor);
                    break;
                default:
                    final String errorMsg = String.format("Xes type '%s' not supported", varCtx.xesTypes().getText());
                    ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

                    parameter = null;
            }

            if (parameter != null) {
                parameters.add(parameter);
            }
        }

        return parameters;
    }

    // Utils
    public ValueAccessorSpecification getValueAccessor(BcqlParser.ValueExpressionContext ctx) {

        if (ctx.variableName() != null) {
            return ValueAccessorSpecification.ofVariable(ctx.getText(), this.state.getBlockchainVariables());
        }

        if (ctx.literal() != null) {
            return this.getLiteral(ctx.literal());
        }

        ExceptionHandler.getInstance().handleException("This value accessor specification is not supported.", new Exception());

        return null;
    }

    public ValueAccessorSpecification getLiteral(BcqlParser.LiteralContext ctx) {
        String type = this.determineLiteralType(ctx);
        return this.getLiteral(type, ctx.getText());
    }

    private String determineLiteralType(BcqlParser.LiteralContext ctx) {

        if (ctx.BOOLEAN_LITERAL() != null) {
            return TypeUtils.BOOL_TYPE_KEYWORD;
        }

        if (ctx.BYTES_LITERAL() != null) {
            return TypeUtils.BYTES_TYPE_KEYWORD;
        }

        if (ctx.INT_LITERAL() != null) {
            return TypeUtils.INT_TYPE_KEYWORD;
        }

        if (ctx.STRING_LITERAL() != null) {
            return TypeUtils.STRING_TYPE_KEYWORD;
        }

        if (ctx.arrayLiteral() != null) {
            if (ctx.arrayLiteral().booleanArrayLiteral() != null) {
                return TypeUtils.toArrayType(TypeUtils.BOOL_TYPE_KEYWORD);
            }

            if (ctx.arrayLiteral().bytesArrayLiteral() != null) {
                return TypeUtils.toArrayType(TypeUtils.BYTES_TYPE_KEYWORD);
            }

            if (ctx.arrayLiteral().intArrayLiteral() != null) {
                return TypeUtils.toArrayType(TypeUtils.INT_TYPE_KEYWORD);
            }

            if (ctx.arrayLiteral().stringArrayLiteral() != null) {
                return TypeUtils.toArrayType(TypeUtils.STRING_TYPE_KEYWORD);
            }
        }

        final String errorMsg = String.format("Determination of literal type failed: Cannot determine type for literal %s.", ctx.getText());
        ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

        return null;
    }

    public ValueAccessorSpecification getLiteral(String type, String literal) {

        final String errorMsg = String.format("Unsupported type: '%s'.", type);

        if (TypeUtils.isArrayType(type)) {
            return getLiteralOfArrayType(type, literal);
        }

        if (TypeUtils.isAddressType(type)) {
            return ValueAccessorSpecification.addressLiteral(literal);
        }

        if (TypeUtils.isBooleanType(type)) {
            return ValueAccessorSpecification.booleanLiteral(literal);
        }

        if (TypeUtils.isBytesType(type)) {
            return ValueAccessorSpecification.bytesLiteral(literal);
        }

        if (TypeUtils.isIntegerType(type)) {
            return ValueAccessorSpecification.integerLiteral(literal);
        }

        if (TypeUtils.isStringType(type)) {
            return ValueAccessorSpecification.stringLiteral(literal);
        }

        ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

        return null;
    }

    private ValueAccessorSpecification getLiteralOfArrayType(String type, String literal) {

        final String errorMsg = String.format("Unsupported type: '%s'.", type);

        if (!TypeUtils.isArrayType(type)) {
            ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

            return null;
        }

        if (TypeUtils.isArrayType(type, TypeUtils.ADDRESS_TYPE_KEYWORD)) {
            return ValueAccessorSpecification.addressArrayLiteral(literal);
        }

        if (TypeUtils.isArrayType(type, TypeUtils.BOOL_TYPE_KEYWORD)) {
            return ValueAccessorSpecification.booleanArrayLiteral(literal);
        }

        if (TypeUtils.isArrayType(type, TypeUtils.BYTES_TYPE_KEYWORD)) {
            return ValueAccessorSpecification.bytesArrayLiteral(literal);
        }

        if (TypeUtils.isArrayType(type, TypeUtils.INT_TYPE_KEYWORD)) {
            return ValueAccessorSpecification.integerArrayLiteral(literal);
        }

        if (TypeUtils.isArrayType(type, TypeUtils.STRING_TYPE_KEYWORD)) {
            return ValueAccessorSpecification.stringArrayLiteral(literal);
        }

        ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

        return null;
    }

    @Override
    public void exitScope(BcqlParser.ScopeContext ctx) {
        if (ctx.filter().genericFilter() != null) {
            this.buildGenericFilter();
        }
    }

    @Override
    public void exitConditionalOrExpression(BcqlParser.ConditionalOrExpressionContext ctx) {
        if (ctx.conditionalOrExpression() != null) {
            this.createBinaryConditionalExpression(GenericFilterPredicateSpecification::or);
        }
    }

    @Override
    public void exitConditionalAndExpression(BcqlParser.ConditionalAndExpressionContext ctx) {
        if (ctx.conditionalAndExpression() != null) {
            this.createBinaryConditionalExpression(GenericFilterPredicateSpecification::and);
        }
    }

    private void createBinaryConditionalExpression(BinaryOperator<GenericFilterPredicateSpecification> constructor) {
        final String errorMsg = "Parse tree error: binary boolean expression requires boolean predicates.";

        if (this.genericFilterPredicates.size() < 2) {
            ExceptionHandler.getInstance()
                .handleException("Parse tree error: binary boolean expression requires at least two predicates.", new Exception());
        }

        if (!(this.genericFilterPredicates.peek() instanceof GenericFilterPredicateSpecification)) {
            ExceptionHandler.getInstance().handleException(errorMsg, new Exception());
        }
        final GenericFilterPredicateSpecification predicate1 = (GenericFilterPredicateSpecification) this.genericFilterPredicates.pop();

        if (!(this.genericFilterPredicates.peek() instanceof GenericFilterPredicateSpecification)) {
            ExceptionHandler.getInstance().handleException(errorMsg, new Exception());
        }

        final GenericFilterPredicateSpecification predicate2 = (GenericFilterPredicateSpecification) this.genericFilterPredicates.pop();

        this.genericFilterPredicates.push(constructor.apply(predicate1, predicate2));
    }

    @Override
    public void exitConditionalComparisonExpression(BcqlParser.ConditionalComparisonExpressionContext ctx) {

        if (ctx.comparators() == null) {
            return;
        }

        if (this.genericFilterPredicates.size() < 2) {
            ExceptionHandler.getInstance().handleException("Parse tree does not contain enough expressions.", new Exception());

            return;
        }

        final Object value2 = this.genericFilterPredicates.pop();
        if (!(value2 instanceof ValueAccessorSpecification)) {
            ExceptionHandler.getInstance().handleException("Can only compare values, but not boolean expressions.", new Exception());

            return;
        }

        final Object value1 = this.genericFilterPredicates.pop();
        if (!(value1 instanceof ValueAccessorSpecification)) {
            ExceptionHandler.getInstance().handleException("Can only compare values, but not boolean expressions.", new Exception());

            return;
        }

        final ValueAccessorSpecification spec1 = (ValueAccessorSpecification) value1;
        final ValueAccessorSpecification spec2 = (ValueAccessorSpecification) value2;

        GenericFilterPredicateSpecification predicate = null;
        switch (ctx.comparators().getText().toLowerCase()) {
            case "==":
                predicate = GenericFilterPredicateSpecification.equals(spec1, spec2);
                break;
            case "!=":
                predicate = GenericFilterPredicateSpecification.notEquals(spec1, spec2);
                break;
            case ">=":
                predicate = GenericFilterPredicateSpecification.greaterThanAndEquals(spec1, spec2);
                break;
            case ">":
                predicate = GenericFilterPredicateSpecification.greaterThan(spec1, spec2);
                break;
            case "<":
                predicate = GenericFilterPredicateSpecification.smallerThan(spec1, spec2);
                break;
            case "<=":
                predicate = GenericFilterPredicateSpecification.smallerThanAndEquals(spec1, spec2);
                break;
            case "in":
                predicate = GenericFilterPredicateSpecification.in(spec1, spec2);
                break;
            default:
                final String errorMsg = String.format("Comparator %s not supported.", ctx.comparators().getText());
                ExceptionHandler.getInstance().handleException(errorMsg, new Exception());
        }

        this.genericFilterPredicates.push(predicate);
    }

    @Override
    public void exitConditionalNotExpression(BcqlParser.ConditionalNotExpressionContext ctx) {

        if (ctx.KEY_NOT() == null) {
            return;
        }

        Object valueExpression = this.genericFilterPredicates.pop();
        if (valueExpression instanceof ValueAccessorSpecification) {
            valueExpression = GenericFilterPredicateSpecification.ofBooleanAccessor((ValueAccessorSpecification) valueExpression);
        }

        if (!(valueExpression instanceof GenericFilterPredicateSpecification)) {
            final String errorMsg = String.format("GenericFilterPredicateSpecification required, but was %s.", valueExpression.getClass());
            ExceptionHandler.getInstance().handleException(errorMsg, new Exception());

            return;
        }

        this.genericFilterPredicates.push(GenericFilterPredicateSpecification.not((GenericFilterPredicateSpecification) valueExpression));
    }

    @Override
    public void exitConditionalPrimaryExpression(BcqlParser.ConditionalPrimaryExpressionContext ctx) {
        if (ctx.valueExpression() != null) {
            this.genericFilterPredicates.push(this.getValueAccessor(ctx.valueExpression()));
        }
    }

    @Override
    public void enterGenericFilter(BcqlParser.GenericFilterContext ctx) {
        LOGGER.info("Prepare generic filter build");
        this.composer.prepareGenericFilterBuild();
    }

    private void buildGenericFilter() {
        LOGGER.info("Build generic filter");

        if (this.genericFilterPredicates.size() != 1) {
            ExceptionHandler.getInstance().handleException("Error in boolean expression tree.", new Exception());
        }

        final Object predicate = this.genericFilterPredicates.pop();

        if (predicate instanceof GenericFilterPredicateSpecification) {
            this.composer.buildGenericFilter((GenericFilterPredicateSpecification) predicate);

            return;
        }

        if (predicate instanceof ValueAccessorSpecification) {
            final GenericFilterPredicateSpecification filterSpec = GenericFilterPredicateSpecification.ofBooleanAccessor(
                (ValueAccessorSpecification) predicate
            );
            this.composer.buildGenericFilter(filterSpec);

            return;
        }

        final String errorMsg = String.format(
            "Building generic filter failed: Unsupported type for specification of generic filter predicates: %s",
            predicate.getClass()
        );
        ExceptionHandler.getInstance().handleException(errorMsg, new Exception());
    }
}
